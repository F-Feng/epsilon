(* vim: set syntax=mma expandtab shiftwidth=4 tabstop=4: *)

(*
 *  mma/EpsilonTools.m
 * 
 *  Copyright (C) 2016 Mario Prausa 
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as 
 *  published by the Free Software Foundation, either version 3 of the 
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *)

BeginPackage["Epsilon`"];
    EpsilonBlocks::usage = "EpsilonBlocks[M] identify possible blocks in matrix M for epsilon.";
    EpsilonSymRules::usage = "EpsilonSymRules[ex] scans ex for symbols and provides rules to translate those generated by epsilon-prepare into mma.";
    EpsilonRead::usage = "EpsilonRead[filename] reads in matrix in epsilon format.";

    {x,ep};

    Begin["Private`"];
        EpsilonBlocks[M_] := Module[{n=1,blocks={},s,A},
            While[n<=Length[M],
                s=1;
                While[True,
                    A = Map[If[# === 0,0,1] &,M[[n;;n+s-1,n+s;;]],{2}];
                    If [Flatten[A] == {} || Union[Flatten[A]] == {0}, Break[]];
                    
                    p = Max[Flatten[(Position[#,1] &)/@A]];
                    s += p;
                ];
                AppendTo[blocks,{n,n+s-1}];
                n += s;
            ];
        blocks];

        EpsilonSymRules[ex_] := Module[{symrule},
            symrule[sym_Symbol] := Module[{str,n},
                str=ToString[sym];

                If [str == "i", Return[{sym->I}]];
                If [StringMatchQ[str,RegularExpression["r\\d+"]],
                    n=ToExpression[StringDrop[str,1]];
                    Return[{sym -> 1/2 + I/2*Sqrt[n]}];
                ];
                If [StringMatchQ[str,RegularExpression["q\\d+"]],
                    n=ToExpression[StringDrop[str,1]];
                    Return[{sym -> 1/2 + 1/2*Sqrt[n]}];
                ];
                If [StringMatchQ[str,RegularExpression["sqrt\\d+"]],
                    n=ToExpression[StringDrop[str,4]];
                    Return[{sym -> Sqrt[n]}];
                ];
                If [StringMatchQ[str,RegularExpression["isqrt\\d+"]],
                    n=ToExpression[StringDrop[str,5]];
                    Return[{sym -> I*Sqrt[n]}];
                ];
            {}];

            Flatten[symrule/@Union[Cases[ex,_Symbol,{0,Infinity}]]]
        ];

        Options[EpsilonRead] = {ReplaceSymbols->True,CheckFuchsian->False,CheckEpsilon->False};

        EpsilonRead[filename_,OptionsPattern[]] := Module[{res,xmat,epcheck},
            res = StringCases[#,{
                RegularExpression["A\\[(.*)\\]:\\s+(.*)"] :> xmat[ToExpression["{$1}"],ToExpression["$2"]],
                RegularExpression["B\\[(.*)\\]:\\s+(.*)"] :> xmat[ToExpression["$1"],ToExpression["$2"]]
            }] &/@ ReadList[filename,String];

            epcheck[mat_List] := Module[{arr,min},
                arr = Select[Flatten[mat],# =!= 0 &];
                If [arr === {}, Return[True]];

                If [Min[Exponent[#,ep,Min] &/@arr] =!= 1, Return[False]];
                If [Max[Exponent[#,ep,Max] &/@arr] =!= 1, Return[False]];
            True];

            If [OptionValue[CheckFuchsian] && !FreeQ[res,xmat[{_,_?(# =!= 0 &)},_List]|xmat[_Integer,_List]],
                Return[$Failed];
            ];

            If [OptionValue[CheckEpsilon] && !And@@Cases[res,xmat[_,m_List]:>epcheck[m],{0,Infinity}],
                Return[$Failed];
            ];

            res = Total[Flatten[res]]/.{
                xmat[{a_,b_},m_List] -> 1/(x-a)^(b+1)*m,
                xmat[a_Integer,m_List] -> x^a*m
            };

            If [OptionValue[ReplaceSymbols],
                res = res/.EpsilonSymRules[res];
            ];
 
            res = Map[Cancel[Together[#]] &,res,{2}];
        res];
    End[];
EndPackage[];

    
   
